global {
  global.padding = 10.0
}

origin {
  origin.x = -200.0
  origin.y = 100.0
}

Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.pink = rgba(1.0, 0.4, 0.7, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.sky = rgba(0.325, 0.718, 0.769, 1.0)
    Colors.lightsky = rgba(0.325, 0.718, 0.769, 0.25)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.lightblue2 = rgba(0.82, 0.88, 0.94, 1.0)
    Colors.lightpink = rgba(0.9, 0.5, 0.5, 0.25)
}

-- Should there be a style for generic Interval
-- without a Subset relationship?
-- It would specify the fields that the subtypes
-- would need to have, like left, right, yval, shape

Reals `R` {
  R.len = 500.0
  R.thickness = 1.5
  R.color = Colors.gray

  R.left = origin.x
  R.right = origin.x + R.len
  R.yval = origin.y

  R.shape = Arrow {
    startX = R.left
    startY = R.yval
    endX = R.right
    endY = R.yval
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

  R.text = Text {
    string = R.label
    rotation = 0.0
  }

  R.labelFn = ensure nearHead(R.shape, R.text, global.padding, global.padding)
}

Real r  -- no "In(r, `R`)"
with Reals `R` {
  r.val = OPTIMIZED
  r.yval = `R`.yval
  r.len = 20.0

  r.shape = Line {
    startX = r.val
    startY = r.yval - (r.len / 2.0)
    endX = r.val
    endY = r.yval + (r.len / 2.0)
    thickness = 2.5
    color = Colors.black
  }

  r.text = Text {
    string = r.label
    rotation = 0.0
  }

  r.inFn = ensure inRange(r.val, R.left, R.right)
  r.labelFn = encourage nearHead(r.shape, r.text, 10.0, 10.0)
}

----------------------------------
-- INTERVAL STYLES

Interval I
where Subset(I, R)
with Reals R { -- TODO: more general, with Interval J
  I.left = OPTIMIZED
  I.right = OPTIMIZED
  I.yval = R.yval

  I.shape = Line { -- horizontal
    startX = I.left
    startY = I.yval
    endX = I.right
    endY = I.yval
    thickness = 7.5
    color = rgba(0.3, 0.3, 0.9, 0.5)
  }

  -- position computed, not optimized
  I.text = Text {
    string = I.label
    -- TODO: This doesn't seem to be computed properly
    -- x = (I.shape.endX - I.shape.startX) / 2.0
    y = I.yval + global.padding
    rotation = 0.0
  }

  I.wfFn = ensure lessThan(I.left, I.right)
  I.liFn = ensure inRange(I.left, R.left, R.right)
  I.riFn = ensure inRange(I.right, R.left, R.right)
  I.labelFn = encourage centerLabel(I.shape, I.text)
  -- I.labelFn = ensure inRange(I.text.x, a.val, b.val)
  -- I.labelFn = encourage nearHead(I.shape, I.text, 0.0, 10.0)
}

Real a; Real b
with Interval I; Reals R
where I := CreateInterval(a, b); Subset(I, R) {
  override a.val = I.left
  override b.val = I.right
  override a.yval = I.yval
  override b.yval = I.yval
}

Real r
with Interval I; Reals R; Real a; Real b
where I := CreateInterval(a, b); In(r, I); Subset(I, R) {
  override r.yval = I.yval
  override r.inFn = ensure inRange(r.val, a.val, b.val)
  override r.shape.color = Colors.red
}

Real a; Real b
with OpenInterval I; Reals R
where I := CreateOpenInterval(a, b); Subset(I, R) {
  -- lines copied from real-analysis-types.sty
  override a.shape = Image {
      path = "left-paren.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-paren.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

Real a; Real b
with ClosedInterval I; Reals R
where I := CreateClosedInterval(a, b); Subset(I, R) {
  -- lines copied from real-analysis-types.sty
  override a.shape = Image {
      path = "left-bracket.svg"
      centerX = a.val
      centerY = a.yval
      lengthX = 10.0
      lengthY = 20.0
  }

  override b.shape = Image {
      path = "right-bracket.svg"
      centerX = b.val
      centerY = b.yval
      lengthX = 10.0
      lengthY = 20.0
  }

    override a.labelFn = encourage near(a.shape, a.text, 0.0, -20.0)
    override b.labelFn = encourage near(b.shape, b.text, 0.0, -20.0)
}

----------------------------------
-- FUNCTION STYLES

/* The selectors for drawing a single function
cascade by first drawing a generic function between two *different* intervals (where Real is a subtype of Interval), drawing a new Real line and setting the relevant pointers. The selectors after it deal with the following specific cases:

- if f : R -> R, set f's domain and codomain accordingly
- if f : (R or I) -> J (where J is an interval that's a subset of R), move J onto the second real number line
- if f : I -> R, f's codomain needs to be the second real number line, otherwise f will be drawn to map onto the first real number line (which is a valid visualization style, just confusing to see)

We currently do not draw f : I -> I. */

/* f : I -> J
 If there is any function from I to J, then we make a second real number line that those functions all share. (This is going to be done for every match, hence the `override` / lack of `override` warnings.) This will achieve the effect of if only one shape had been made. 

TODO: Doesn't match f : R -> R right now but will match if we add a "could equal" for I ?= J */

Function f
with Interval I; Interval J; Reals `R`
-- Does NOT match with generic "Reals R"!
where f := CreateFunction(I, J) {
  `R`.yval2 = `R`.yval - 100.0 -- function drawn downward

  `R`.shape2 = Arrow {
    startX = `R`.left
    startY = `R`.yval2
    endX = `R`.right
    endY = `R`.yval2
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape2_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape2_labelFn = ensure nearHead(`R`.shape2, `R`.shape2_text, global.padding, global.padding)

  -------------------------------------------------

  f.val = OPTIMIZED   -- placeholder, TODO sample f's value
  f.domain = I.shape -- TODO: we really want to be able to write `f.domain = I` but it doesn't even parse
  f.codomain = J.shape

  f.shape = Curve {
    pathData = sampleFunctionArea(f.domain, f.codomain, 5.0, 30.0)
    strokeWidth = 0.0
    fill = Colors.lightpink
    color = Colors.lightpink
    rotation = 0.0
  }

  f.text = Text {
    string = f.label
    rotation = 0.0
  }

  f.text.x = average(midpointX(f.domain), midpointX(f.codomain)) + 10.0
  f.text.y = average(f.domain.startY, f.codomain.startY)
}

-- This is simply copy-pasted from the previous selector except for f.domain and f.codomain
-- Not sure how to make it more generic, since we do want to do something special for f : I -> I

Function f
with Reals `R`
where f := CreateFunction(`R`, `R`) {
  `R`.yval2 = `R`.yval - 100.0 -- function drawn downward

  `R`.shape2 = Arrow {
    startX = `R`.left
    startY = `R`.yval2
    endX = `R`.right
    endY = `R`.yval2
    thickness = `R`.thickness
    color = `R`.color
    rotation = 0.0
  }

 `R`.shape2_text = Text {
    string = `R`.label
    rotation = 0.0
  }

  `R`.shape2_labelFn = ensure nearHead(`R`.shape2, `R`.shape2_text, global.padding, global.padding)

  -------------------------------------------------

  f.val = OPTIMIZED
  f.domain = `R`.shape
  f.codomain = `R`.shape2

  f.shape = Curve {
    pathData = sampleFunctionArea(f.domain, f.codomain, 5.0, 30.0)
    strokeWidth = 0.0
    fill = Colors.lightpink
    color = Colors.lightpink
    rotation = 0.0
  }

  f.text = Text {
    string = f.label
    rotation = 0.0
  }

  f.text.x = average(midpointX(f.domain), midpointX(f.codomain)) + 10.0
  f.text.y = average(f.domain.startY, f.codomain.startY)
}

/* We have no style for f : I -> I where I is a generic interval in R.  Hard to visualize with the "mass" function. ut we could easily draw a loopy arrow. */

Function f
with Interval I; Interval J; Reals `R`
where f := CreateFunction(I, J);
      Subset(J, `R`) { -- i.e. J is not of type Reals

  override J.yval = `R`.yval2
  -- avoid cycles if I=R in generic (I,J) selector
}

Function f
with Interval I; Reals R
where f := CreateFunction(I, R) {

  override f.codomain = R.shape2
  -- specifically draw from the current R to new R
  -- otherwise, will show it from R to itself
  -- (which is also a valid viz)
}

/*
Function `g` {
	 override `g`.shape.fill = Colors.lightsky
	 override `g`.shape.color = Colors.lightsky
} */

/* h = g . f

If there is a composition of functions, draw a third R for the second function. Again, this is technically going to be made for every match, but overridden to be the same thing. (Does NOT deal with composition of 3 functions, i = h . g . f) */

Function h;
Function g;
Function f
where h := compose(g, f);
      h := CreateFunction(A, R);
      g := CreateFunction(B, R);
      f := CreateFunction(A, B)
      -- disallow equality for simplicity
      -- TODO: deal with these later
      -- A ?= B; B ?= C; h ?= g; g ?= f
      -- TODO: generalize the selector to three intervals
with Interval A, B;
     Reals R
{
  R.yval3 = R.yval2 - 100.0 -- function drawn downward

  R.shape3 = Arrow {
    startX = R.left
    startY = R.yval3
    endX = R.right
    endY = R.yval3
    thickness = R.thickness
    color = R.color
    rotation = 0.0
  }

 R.shape3_text = Text {
    string = R.label
    rotation = 0.0
  }

  R.shape3_labelFn = ensure nearHead(R.shape3, R.shape3_text, global.padding, global.padding)

  -------------------------------------------------
  -- move B to be in f's codomain
  -- B matches J
  -- may not work in general; specialized to our case
  -- TODO: work out how it generalizes
  override B.yval = R.yval2

  -- update f to point to J
  -- TODO: this should match the `f(I) \subset J` in Sub
  override f.codomain = B.shape
  override f.shape.endX = midpointX(B.shape)

  -- move g's codomain to be the third R
  override g.codomain = R.shape3
  override g.shape.endY = R.yval3 + global.padding

  override h.codomain = R.shape3
  -- delete h's shape, label, etc.
  delete h.val
  delete h.shape
  delete h.text
  delete h.labelFn
}

-- TODO: selectors to make fourth, fifth, etc. R
-- specifically for the composition of three, four functions

----------------------------------
-- FUNCTION APPLICATION STYLES

-- y := f(x)
Real y; Function f
with Interval I; Interval J; Real x; Reals R
where y := apply(f, x); f := CreateFunction(I, J); In(x, I) {

  -- so it's not necessary to say In(y, J)
  override y.yval = J.yval

  f.pointwise_shape = Curve {
    -- TODO: syntax for working with 2-tuples and lists
    -- TODO: why does this not interpolate properly with offset = (0, 0)?
    -- TODO: more curves = more time to optimize?
    pathData = makeCurve(x.val, I.yval - 2.0 * global.padding, y.val, J.yval + 2.0 * global.padding, -10.0, -(J.yval - I.yval) / 1.5)
    strokeWidth = 2.0
    fill = Colors.none
    color = Colors.sky
    rotation = 0.0
    -- TODO: rename to account for arrow directionality
    right-arrowhead = True
  }

/* f.pointwise_shape = Arrow {
    startX = x.val
    startY = I.yval - global.padding
    endX   = y.val
    endY   = J.yval + global.padding
    thickness = R.thickness
    color = f.shape.color
    rotation = 0.0
  } */

}